***
*** Overlay kumac for KTEV
***
*** [1] is Data histogram
*** [2] is MC histogram
*** [3] is the TITLE

macro overall hdata=-1 hmc=-1 title=' ' plim=' ' fscal=0.0 _
  mccolor=2  olimlo=-999 olimhi=-999 proj=0 plog=0 pnoovl=0 pnorat=-999 _
  mm='' pmin=-999 pmax=-999 pchi2=1 old=0 rr='' rmin=.5 rmax=1.5 _
  banxy=0 banmin=0 banmax=0 _
  pfil=0 pscal=0 flim=' ' fitn=1 debug=0 save=0 symsize=0.05 nosym=0 _
  mcopt=' ' rebin=1 pnoprint=0 bino=0 chirn=0 schi=0.25 hwid=1 _
  zonstyle=1 xpatit=' ' ypatit=' ' xratit=' ' yratit=' '

*-- Print out usage info
if ([hmc] .eq. '-1') then
  mess ' '
  mess 'Usage:   overall [hid_data] [hid_mc]'
  mess ' '
  mess '  title=''This is the title'''
  mess '  plog=1       Use logarithmic Y axis (otherwise, determined by LOGY option)'
  mess '  pnoovl=1     Do not plot overlay'
  mess '  pnorat=1     Do not plot ratio (this is the default if only one zone)'
  mess '  pnoprint=1   Do not print statistics to screen'
  mess '  pchi2=0      Do not print chisq above plot'
  mess '  pscal=1      Print scale factor'
  mess '  pfil=1       Prompt user for descriptions of data & MC, and make key'
  mess '  symsize=0.2  Change symbol size (default = 0.05)'
  mess '  nosym=1      Avoid use of plot symbols (for faster plotting)'
  mess '  bino=1       Use binominal errors'
  mess ' '
  mess '  plim=''(11:80)''       Bin range for plotting'
  mess '                          Can be tacked onto hid_data'
  mess '  flim=''(11:80)''       Bin range for fitting ratio (default = plot range)'
  mess '                          Can be tacked onto hid_mc'
  mess '  olimlo=.2 olimhi=.8  Range used for normalizing (default = fit range)'
  mess '  pmin=15. pmax=40.    Vertical scale for overlay plot'
  mess '  mm=15.,40.           Same as above'
  mess '  rmin=0.8 rmax=1.2    Vertical scale for ratio plot'
  mess '  rr=0.8,1.2           Same as above'
  mess '  fscal=1.0            Override automatic scaling in overlay plot'
  mess '  rebin=10             Merge 10 bins'
  mess '  fitn=2               Order of polynomial for fit to ratio (-1 = no fit)'
  mess '  chirn=1      Rescale errors by sqrt(chi^2) to refit'
  mess '  schi=0.25    Size of Chi^2/dof text'
  mess '  save=1       Save intermediate histograms and vectors'
  mess ' '
  mess '  proj=1     Project 2D histogram onto X axis (2 => Y axis)'
  mess '  banxy=1 banmin=40. banmax=100.   Project Y-band onto X axis'
  mess '  zonstyle=1   Put ratio under data plot'
  mess '  xpatit=''This is the x-axis title for plot'''
  mess '  ypatit=''This is the y-axis title for plot'''
  mess '  xratit=''This is the x-axis title for ratio plot'''
  mess '  yratit=''This is the y-axis title for ratio plot'''
  mess ' '
  exitm
endif

***
*** Save settings
***

origcdir = $HCDIR()
call hplopt('LOGY',-1)
origlogy = $iquest(11)
call hplopt('FILE',-1)
origfile = $iquest(11)
origifil = $GRAFINFO('?FILE')
origcfon = $GRAFINFO('?CFON')
orighcol = $GRAFINFO('?HCOL')
orightyp = $GRAFINFO('?HTYP')
xzones = $GRAFINFO('XZONES')
yzones = $GRAFINFO('YZONES')
nzones = [xzones] * [yzones]

if [pnorat]=-999 then
  if ([nzones] .eq. 1) then
    pnorat = 1     | Turn off ratio plot if only one zone
    if [pnoovl]=1 then
      pnorat = 0
    endif
  else
    pnorat = 0
  endif
endif
set hwid [hwid]
***
*** Input
***

hdatause = 987633
hmcuse = 987634

* See if the data histogram specifies a bin range for plotting
exec hpl#binloc [hdata]
binloc = [@]
if ([binloc] .gt. 0) then
  strlen = $len([hdata])
  nch = [strlen] - [binloc] + 1
  plim_t = $substring([hdata],[binloc],[nch])
  if ([plim] .eq. ' ') then
    plim = [plim_t]
  endif
  nch = [binloc] - 1
  hdata = $substring([hdata],1,[nch])
endif

* See if the MC histogram specifies a bin range for fitting ratio plot
exec hpl#binloc [hmc]
binloc = [@]
if ([binloc] .gt. 0) then
  strlen = $len([hmc])
  nch = [strlen] - [binloc] + 1
  flim_t = $substring([hmc],[binloc],[nch])
  if ([flim] .eq. ' ') then
    flim = [flim_t]
  endif
  nch = [binloc] - 1
  hmc = $substring([hmc],1,[nch])
endif

* If a plot range was specified, use it for the fit range too unless 
*  a fit range was explicitly specified
if ([flim] .eq. ' ') then
  flim = [plim]
endif

* If a fit range was specified, use it for the normalization range too unless 
*  a normalization range was explicitly specified
if ([flim] .ne. ' ') then
  if ([olimlo] .eq. -999 .and. [olimhi] .eq. -999) then
    chpos = $index([flim],':')
    nch = [chpos] - 2
    olimlo = $substring([flim],2,[nch])
    strlen = $len([flim])
    nch = [strlen] - [chpos] - 1
    chpos = [chpos] + 1
***    if ([nch] .gt. 0) then
      olimhi = $substring([flim],[chpos],[nch])
***    else
***      olimhi = 9999999.9
***    endif
  endif
endif

* If 'rr' was specified, copy it to rmin and rmax
chpos = $INDEX([rr],',')
if ([chpos] .ne. 0) then
  temp = $SUBSTRING([rr],1,[chpos]-1)
  if ([temp] .ne. '') then
    rmin = [temp]
  endif
  temp = $SUBSTRING([rr],[chpos]+1)
  if ([temp] .ne. '') then
    rmax = [temp]
  endif
endif

* If 'mm' was specified, copy it to pmin and pmax
chpos = $INDEX([mm],',')
if ([chpos] .ne. 0) then
  temp = $SUBSTRING([mm],1,[chpos]-1)
  if ([temp] .ne. '') then
    pmin = [temp]
  endif
  temp = $SUBSTRING([mm],[chpos]+1)
  if ([temp] .ne. '') then
    pmax = [temp]
  endif
endif

* Try to figure out what logical units the data and MC histos are from
datalun = ''
if ($substring([hdata],1,2) .eq. '//') then
  strlen = $len([hdata])
  nch = [strlen] - 2
  strmod = $substring([hdata],3,[nch])
  chpos = $index([strmod],'/')
  nch = [chpos] - 1
  datalun = '//' // $substring([strmod],1,[nch])
  hdatbase = $substring([hdata],[nch]+3)
endif

mclun = ''
if ($substring([hmc],1,2) .eq. '//') then
  strlen = $len([hmc])
  nch = [strlen] - 2
  strmod = $substring([hmc],3,[nch])
  chpos = $index([strmod],'/')
  if ([chpos] .gt. 0) then
    nch = [chpos] - 1
  else
    nch = $len([strmod])
    hmc = [hmc] // [hdatbase]
  endif
  mclun = '//' // $substring([strmod],1,[nch])
  nch = [chpos] - 1
endif

* Parse options for projections/bands
if ([proj] .eq. 1) then
  hdata = '('//[hdata]//').PROX'
  hmc = '('//[hmc]//').PROX'
endif
if ([proj] .eq. 2) then
  hdata = '('//[hdata]//').PROY'
  hmc = '('//[hmc]//').PROY'
endif
if ([banxy] .eq. 1) then
  hdata = '('//[hdata]//').BANX.('//[banmin]//':'//[banmax]//')'
  hmc = '('//[hmc]//').BANX.('//[banmin]//':'//[banmax]//')'
endif
if ([banxy] .eq. 2) then
  hdata = '('//[hdata]//').BANY.('//[banmin]//':'//[banmax]//')'
  hmc = '('//[hmc]//').BANY.('//[banmin]//':'//[banmax]//')'
endif

* Now prep the histos
exec hpl#hcopy [hdata] [hdatause] debug=[debug]
if ([title] .eq. ' ') then
  title = $HTITLE([hdatause])
endif
exec hpl#hcopy [hmc] [hmcuse] [title] debug=[debug]
**
** Rebin histos
**

if [rebin]<>1 then
  nbin = $hinfo([hdatause],'xbins')
  vec/cr xx([nbin])
  vec/cr yy([nbin])
  vec/cr exx([nbin])
  vec/cr eyy([nbin])
  newbin = [nbin]/[rebin]
  rebin [hdatause] xx yy exx eyy [newbin] 1 [nbin] N
  h/cr/1d 999000 $htitle([hdatause]) [newbin] _
     $hinfo([hdatause],'xmin')  $hinfo([hdatause],'xmax') 
  put/cont  999000 yy

  rebin [hmcuse] xx yy exx eyy [newbin] 1 [nbin] N
  h/cr/1d 999001 $htitle([hmcuse]) [newbin] _
     $hinfo([hmcuse],'xmin')  $hinfo([hmcuse],'xmax') 
  put/cont  999001 yy
 
  h/del [hdatause]
  h/co 999000 [hdatause] 
  h/del 999000

  h/del [hmcuse]
  h/co 999001 [hmcuse] 
  h/del 999001

  vec/del xx
  vec/del yy
  vec/del exx
  vec/del eyy
endif

if [old]=0 then
  if $HINFO([hdatause],'YBINS')<>0 then
    mess Error: histogram [hdata] is 2-dimensional
    goto END
  endif
  if $HINFO([hmcuse],'YBINS')<>0 then
    mess Error: histogram [hmc] is 2-dimensional
    goto END
  endif
endif

hdata = [hdatause]
hmc = [hmcuse]

***
*** data
***
nbin = $hinfo([hdata],'xbins')
xlo = $hinfo([hdata],'xmin')
xhi = $hinfo([hdata],'xmax')
wbin = ([xhi]-[xlo])/[nbin]
vec/cr ovdata([nbin])
vec/cr edata([nbin])
vec/cr xdata([nbin])
vec/cr dummy([nbin])
get/cont [hdata] ovdata
get/err [hdata] edata
get/abs [hdata] xdata
***
*** MC
***
nbinmc = $hinfo([hmc],'xbins')
xlomc = $hinfo([hmc],'xmin')
xhimc = $hinfo([hmc],'xmax')
wbinmc = ([xhimc]-[xlomc])/[nbinmc]
if ([wbin] .ne. [wbinmc]) then
  mess Error: Data and MC have different binning
  goto END
endif
if [mcopt]='p' then
  if $vexist( xmc ) then
     v/del xmc
     v/del mcdummy
  endif

  vec/cr xmc([nbin])
  vec/cr mcdummy([nbin])
  get/abs [hmc] xmc
endif

vec/cr tovmc([nbinmc])
vec/cr temc([nbinmc])
get/cont [hmc] tovmc
get/err [hmc] temc

vec/cr ovmc([nbin])
vec/cr emc([nbin])

*-- This section is in case the data and MC histograms have different
*-- numbers of bins.  (But the bin widths are required to be the same.)
boffl = ([xlomc]-[xlo]) / [wbin]
boffh = ([xhimc]-[xhi]) / [wbin]
if ([boffl] .gt. 0) then
  bfrl = 1
  btol = [boffl] + 1
else
  bfrl = 1 - [boffl]
  btol = 1
endif
if ([boffh] .gt. 0) then
  bfrh = [nbinmc] - [boffh]
  btoh = [nbin]
else
  bfrh = [nbinmc]
  btoh = [nbinmc] + [boffl] - [boffh]
endif

vec/copy tovmc([bfrl]:[bfrh]) ovmc([btol]:[btoh])
vec/copy temc([bfrl]:[bfrh]) emc([btol]:[btoh])

vec/del tovmc
vec/del temc

***
*** Histogram limits for scaling and ratio
***
blo = 1
bhi = [nbin]
if ( [olimlo]<>-999 .and. [olimhi]<>-999 ) then
  useolim = 1

  if ([olimlo] .eq. '') then
    blo = 1
  else
    if ($INDEX([olimlo],'.') .gt. 0) then
      blo = ( ([olimlo]-[xlo]) / [wbin] ) + 1.0
    else
      blo = [olimlo]
    endif
  endif
  blo = $FORMAT([blo],I)
  if ([blo] .lt. 1) then
    blo = 1
  endif

  if ([olimhi] .eq. '') then
    bhi = 1
  else
    if ($INDEX([olimhi],'.') .gt. 0) then
      bhi = ( ([olimhi]-[xlo]) / [wbin] ) + 1.0
    else
      bhi = [olimhi]
    endif
  endif
  bhi = $FORMAT([bhi],I)
  if ([bhi] .gt. [nbin]) then
    bhi = [nbin]
  endif

***  blo = int( ([olimlo]-[xlo]) / [wbin] ) + 1
***  bhi = int( ([olimhi]-[xlo]) / [wbin] + 0.5 )
***  if [bhi]>[nbin] then
***    bhi = [nbin]
***  endif
else
  useolim = 0
endif
***
*** scale the mc
***
if [fscal]=0 then

  if [useolim]=0 then
    sigma datasum = vsum(ovdata)
    sigma mcsum = vsum(ovmc)
    sigma vfscal = datasum/mcsum
    sigma evfscal = vfscal*sqrt((1.0/datasum) + (1.0/mcsum)) 
  else
    sigma tempsum = sumv(ovdata)
    if [blo]=1 then
       sigma datasum = tempsum([bhi])
    else
       sigma datasum = tempsum([bhi]) - tempsum([blo]-1)
    endif
    sigma tempsum = sumv(ovmc)
    if [blo]=1 then
      sigma mcsum = tempsum([bhi])
    else
      sigma mcsum = tempsum([bhi]) - tempsum([blo]-1)
    endif
    sigma vfscal = datasum/mcsum
    sigma evfscal = vfscal*sqrt((1.0/datasum) + (1.0/mcsum)) 
  endif

else
  
  vec/cr vfscal(1) r [fscal]
  vec/cre evfscal(1) r 0.0

endif

sigma smc = ovmc*vfscal(1)
sigma esmc = emc*vfscal(1)

***
*** Calculate the Chi2 (between olimlo and olimhi)
***
**sigma allone=array([nbin],1.0)
**sigma anydata=min(abs(ovdata),allone)
sigma anydata = ovdata NE 0
sigma ndata=vsum(anydata)

sigma chib = (ovdata-smc)*(ovdata-smc)/(esmc*esmc + edata*edata)
sigma fixchib = chib*anydata

if [useolim]=1 then
  sigma temp=sumv(fixchib)
  if ([blo]=1) then
    sigma chi2 = temp([bhi]) 
  else
    sigma chi2 = temp([bhi]) - temp([blo]-1)
  endif
**  sigma dof = [bhi] - [blo]
  sigma count = array([nbin],1#[nbin])
  sigma climit = (count GE [blo]) AND (count LE [bhi]) 
  sigma ndata = vsum(climit*anydata)
  sigma chidof = chi2/(ndata(1)-1.0)
  sigma dof = (ndata(1)-1.0)
else
  sigma chidof=vsum(fixchib)/(ndata(1)-1.0)
  sigma chi2 = vsum(fixchib)
  sigma dof = (ndata(1)-1.0)
endif


***
*** Plot the overlay
*** KTEV CONVENTION: Data - Points   MC - Histo
***
hout = 987635
xbins = $HINFO([hdata],'XBINS')
xmin = $HINFO([hdata],'XMIN')
xmax = $HINFO([hdata],'XMAX')
h/cre/1d [hout] [title] [xbins] [xmin] [xmax]
put/cont [hout] smc
maxmc = $hinfo([hout],'MAX')
maxdata = $sigma(vmax(ovdata))

uselogy = [origlogy]

if ([plog] .eq. 1) then
  opt logy
  uselogy = 1
endif

if ([uselogy] .eq. 1) then
  maxout = 2.0*$sigma(max([maxmc],[maxdata]))
else
  maxout = 1.1*$sigma(max([maxmc],[maxdata]))
endif

***put/err [hout] esmc
set hcol [mccolor]
max [hout] [maxout]

if ([pmin] .ne. -999) then
   min [hout] [pmin]
endif
if ([pmax] .ne. -999) then
   max [hout] [pmax]
endif

if [pnoovl]=0 then

  opt nfil
  if ([origfile] .eq. 1) then
    if ([datalun] .ne. '') then
      opt file
      set file 2
      set cfon -40
      cd [datalun]
    endif
  endif

  * Plot the data (mc???)
  if [mcopt]='p' then
     hpl [hout]$unquote([plim]) func
     h/get_vec/cont [hout] ovmc
     h/get_vec/err [hout] emc
     opt utit
     title $HTITLE([hout]) u
**     g/hp/sym xmc ovmc [nbin] 20 [symsize]
     v/plot ovmc%xmc ! CLs
     opt htit
  else
    exec hpl [hout]$unquote([plim]) $unquote([mcopt])
  endif

****  exec hpl [hout]$unquote([plim]) $unquote([mcopt])
  opt nfil

  if ([origfile] .eq. 1) then
    if ([mclun] .ne. '') then
      opt file
      set file 3
      set cfon -40
      cd [mclun]
      exec hpl [hout]$unquote([plim]) s
      opt nfil
    endif
  endif
  set cfon [origcfon]

  * Plot the scaled overlay
  set hcol 1
  if ([nosym] .eq. 0) then
    if [mcopt]='p' then
      g/hp/sym xdata ovdata [nbin] 20 [symsize]
    else
      g/hp/err xdata ovdata dummy edata [nbin] 20 [symsize]
    endif
  else
    exec hpl [hdata] se
  endif

  *-- write the axis titles
  hpl/atit [xpatit] [ypatit]
endif

set cfon [origcfon]
set hcol 1
c2 = $format($sigma(chi2),f1.1)
d2 = $format($sigma(int(dof(1))),i1)
tchi = [v]//'^2!/dof = '//[c2]//' / '//[d2]
if [pchi2]=1 then
  if [old]=0 then
    if [pnoovl]=0 then
      exec itxl 0.0 1.01 [tchi] [schi] 4 
    endif
  endif
endif

s2 = $format($sigma(vfscal),f2.2)
tscal = Scale = [s2]
if [pscal]=1 then
  if [old]=0 then
    exec itxl 0.7 1.02 [tscal] .3 4 
  endif
endif

if [pfil]=1 then
  read tfil 'Enter Describtion of Data'
  exec itxl 0.8 .95 [tfil] .1 1
  read tfil 'Enter Describtion of MC'
  exec itxl 0.8 .925 [tfil] .1 1
endif


***
*** See what zone we are currently in (only if more than one X zone)
***
ratzon = 0
nxtzon = 0

if ([xzones] .gt. 1) then

  curnt = $GRAFINFO('NT')
  selnt 1
  winx1 = $GRAFINFO('VPXMIN')
  winx2 = $GRAFINFO('VPXMAX')
  winxs = [winx2] - [winx1]
  winy1 = $GRAFINFO('VPYMIN')
  winy2 = $GRAFINFO('VPYMAX')
  winys = [winy2] - [winy1]

  selnt [curnt]
  vpx = $GRAFINFO('VPXMIN') + $GRAFINFO('VPXMAX')
  vpx = $sigma( (0.5*[vpx]-[winx1]) * [xzones] / [winxs] )
  zonex = $FORMAT([vpx],I1)
  vpy = $GRAFINFO('VPYMIN') + $GRAFINFO('VPYMAX')
  vpy = $sigma( (1.0 - (0.5*[vpy]-[winy1])/[winys]) * [yzones] )
  zoney = $FORMAT([vpy],I1)
  curzon = $sigma( [zoney] * [xzones] + [zonex] + 1 )

  ratzon = [curzon] + [xzones]
  if ([ratzon] .lt. [nzones]) then
    if ( $sigma(mod([ratzon],[xzones])) .ne. 0 ) then
      nxtzon = [curzon] + 1
    else
      nxtzon = 0
    endif
  elseif ([ratzon] .eq. [nzones]) then
    nxtzon = -1     | Special code 
  else
    ratzon = 0
    nxtzon = 0
  endif
  if ([pnorat] .eq. 1 ) then
    ratzon = 0
    nxtzon = 0
  endif
endif

if ([ratzon] .ne. 0) then
  if ([pnorat]=0) then
    if ([pnoovl]=0) then
      if [zonstyle]=1 then    
        zone [xzones] [yzones] [ratzon] s 
      endif
    endif
  endif
endif

***
*** Calculate the Ratio Data/MC
***
sigma ratio = ovdata/smc
if [bino]=0 then
 sigma eratio = ratio*sqrt((edata/ovdata)*(edata/ovdata)+(esmc/smc)*(esmc/smc))
else
 mes doing bino errors
 sigma eratio = sqrt(abs(ovdata/ovmc*(1-ovdata/ovmc)/ovmc))/vfscal(1)
endif

h/op/reset [hout]
put/cont [hout] ratio
put/err [hout] eratio
opt liny
opt nfil
if [mcopt]='p' then
  max [hout] [rmax]
  min [hout] [rmin]
  max [hout] [rmax]
  if [pnorat]<>1 then
    exec hpl [hout]$unquote([plim]) func
    wait
    if [chirn]=1 then
      v/fit xdata ratio eratio p[fitn] s
      hp/err xdata ratio dummy eratio [nbin] 20 [symsize]
    else
      v/fit xdata ratio eratio p[fitn] s
      hp/err xdata ratio dummy eratio [nbin] 20 [symsize]
    endif
  endif
else
  if ([fitn] .ge. 0) then
    exec hpl#hfit [hout]$unquote([flim]) p[fitn] "0q"
    if [chirn]=1 then
      call ~jagraham/paw/getfit.for([hout])
      sigma eratio = eratio*sqrt(getchi(1))
      put/err [hout] eratio
      exec hpl#hfit [hout]$unquote([flim]) p[fitn] "0q"
    endif      
  endif

  max [hout] [rmax]
  min [hout] [rmin]
  max [hout] [rmax]
  if [pnorat]<>1 then
    exec hpl [hout]$unquote([plim]) 
  endif
endif
if [pnorat]<>1 then
  if ([fitn] .eq. -1) then
    igset ltyp 3
    dline [xmin] [xmax] 1.0 1.0
    igset ltyp 0
  endif

  if ([pnoovl]<>1 ) then

    if [zonstyle]=1 then
      if ([nxtzon] .gt. 0) then
	zone [xzones] [yzones] [nxtzon] s
      elseif ([nxtzon] .eq. -1) then
	zone [xzones] [yzones]
      endif
    endif
  endif
  *-- write the axis titles
  hpl/atit [xratit] [yratit]

endif

printout:

if [pnoprint]=1 goto cleanup

message 'Chi2/DOF = '//$sigma(chidof)
message 'Scale Factor = '//$sigma(vfscal)//' +- '//$sigma(evfscal)
***
*** Clean up
***
cleanup:

if [save]=1 goto end

exec ovreset

end:

if ([origlogy] .eq. 1) then
  opt logy
else
  opt liny
endif
if ([origfile] .eq. 1) then
  opt file
else
  opt nfil
endif
set hcol [orighcol]
set htyp [orightyp]
set file [origifil]

cd [origcdir]

return


*-------------------------------------------
macro itxl
***
*** Itx command but with positions as fractions of coord system
*** (from Aaron's itxl.kumac)
***

xf = [1]
yf = [2]
str = [3]
igset txfp -21
igset chhe [4]
igset txci [5]
igset txal 0

xlo = $grafinfo('wnxmin')
xhi = $grafinfo('wnxmax')
ylo = $grafinfo('wnymin')
yhi = $grafinfo('wnymax')

xput = [xlo] + ([xhi]-[xlo])*[xf]
yput = [ylo] + ([yhi]-[ylo])*[yf]

call hplopt('LOGY',-1)
temp = $iquest(11)

**if $option('logy')=1 then
if [temp]=1 then
  yput = $sigma(10**([yput]))
endif

call hplopt('NZFL',-1)

call hplopt('LOGX',-1)
temp2 = $iquest(11)

**if $option('logx')=1 then
if [temp2]=1 then
  xput = $sigma(10**([xput]))
endif

itx [xput] [yput] [str] 
igset txci 1

return

macro signif hdata=-1 hmc=-1 pnorat=0

if ([hmc] .eq. '-1') then
  mess ' '
  mess 'Usage:   overall#signif [hid_data] [hid_mc]'
  mess ' '
endif

***
*** Save settings
***

origcdir = $HCDIR()
call hplopt('LOGY',-1)
origlogy = $iquest(11)
call hplopt('FILE',-1)
origfile = $iquest(11)
origifil = $GRAFINFO('?FILE')
origcfon = $GRAFINFO('?CFON')
orighcol = $GRAFINFO('?HCOL')
orightyp = $GRAFINFO('?HTYP')
xzones = $GRAFINFO('XZONES')
yzones = $GRAFINFO('YZONES')
nzones = [xzones] * [yzones]
if [pnorat]=0 then
  if ([nzones] .eq. 1) then
    pnorat = 1     | Turn off ratio plot if only one zone
    if [pnoovl]=1 then
      pnorat=0
    endif
  else
    pnorat=0
  endif
endif

***
*** Input
***

hdatause = 987633
hmcuse = 987634

* Try to figure out what logical units the data and MC histos are from
datalun = ''
if ($substring([hdata],1,2) .eq. '//') then
  strlen = $len([hdata])
  nch = [strlen] - 2
  strmod = $substring([hdata],3,[nch])
  chpos = $index([strmod],'/')
  nch = [chpos] - 1
  datalun = '//' // $substring([strmod],1,[nch])
endif

mclun = ''
if ($substring([hmc],1,2) .eq. '//') then
  strlen = $len([hmc])
  nch = [strlen] - 2
  strmod = $substring([hmc],3,[nch])
  chpos = $index([strmod],'/')
  nch = [chpos] - 1
  mclun = '//' // $substring([strmod],1,[nch])
endif

* Now prep the histos
exec hpl#hcopy [hdata] [hdatause] debug=[debug]
if ([title] .eq. ' ') then
  title = $HTITLE([hdatause])
endif
exec hpl#hcopy [hmc] [hmcuse] [title] debug=[debug]

return

macro ovreset

hdatause = 987633
hmcuse = 987634
hout = 987635

h/del [hdatause]
h/del [hmcuse]
h/del [hout]

vec/del vfscal
vec/del ovdata
vec/del edata
vec/del ovmc
vec/del emc
vec/del smc
vec/del esmc
vec/del xdata
vec/del dummy
**vec/del allone
vec/del anydata
vec/del chib
vec/del fixchib
vec/del evfscal
if ( [fscal]=0 ) then
  vec/del datasum,mcsum
endif
if ([pnorat] .eq. 0) then
  vec/del ratio
  vec/del eratio
endif
set htyp 0

return

macro sum id sxmin='missing' sxmax='missing' symin='missing' symax='missing'

*-- Get number of bins
  xbins = $HINFO([id],'XBINS')
  ybins = $HINFO([id],'YBINS')

  xmin = $HINFO([id],'XMIN')
  xmax = $HINFO([id],'XMAX')
  xwid = ( [xmax] - [xmin] ) / [xbins]

  if ([sxmin] .eq. 'missing') then
    xbmin = 1
  elseif ( $INDEX([sxmin],'.') .gt. 0) then
    xbmin = ( ([sxmin]-[xmin]) / [xwid] ) + 1
  else
    xbmin = [sxmin]
  endif

  if ([sxmax] .eq. 'missing') then
    xbmax = [xbins]
  elseif ( $INDEX([sxmax],'.') .gt. 0) then
    xbmax = ( ([sxmax]-[xmin]) / [xwid] )
  else
    xbmax = [sxmax]
  endif

  zxbins = [xbmax] - [xbmin] + 1

  if ([ybins] .eq. 0) then

    vec/cre hpltmp([xbins])
    get/cont [id] hpltmp
    vec/cre hpltmp2([zxbins])
    vec/copy hpltmp([xbmin]:[xbmax]) hpltmp2
    sum = $sigma( vsum(hpltmp2) )
    vec/del hpltmp,hpltmp2

  else

    ymin = $HINFO([id],'YMIN')
    ymax = $HINFO([id],'YMAX')
    ywid = ( [ymax] - [ymin] ) / [ybins]

    if ([symin] .eq. 'missing') then
      ybmin = 1
    elseif ( $INDEX([symin],'.') .gt. 0) then
      ybmin = ( ([symin]-[ymin]) / [ywid] ) + 1
    else
      ybmin = [symin]
    endif

    if ([symax] .eq. 'missing') then
      ybmax = [ybins]
    elseif ( $INDEX([symax],'.') .gt. 0) then
      ybmax = ( ([symax]-[ymin]) / [ywid] )
    else
      ybmax = [symax]
    endif

    zybins = [ybmax] - [ybmin] + 1

    vec/cre hpltmp([xbins],[ybins])
    get/cont [id] hpltmp
    vec/cre hpltmp2([zxbins],[zybins])
    do izybin = 1, [zybins]
      iybin = [izybin] + [ybmin] - 1
      vec/copy hpltmp([xbmin]:[xbmax],[iybin]) hpltmp2(1:[zxbins],[izybin])
    enddo
    sum = $sigma( vsum(hpltmp2) )
    vec/del hpltmp,hpltmp2

  endif

return [sum]

